--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 
]=]

-- Instances: 78 | Scripts: 16 | Modules: 1 | Tags: 0
local G2L = {};

-- StarterGui.GUI
G2L["1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"));
G2L["1"]["Name"] = [[GUI]];
G2L["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;


-- StarterGui.GUI.OpenClose
G2L["2"] = Instance.new("TextButton", G2L["1"]);
G2L["2"]["TextWrapped"] = true;
G2L["2"]["BorderSizePixel"] = 0;
G2L["2"]["TextSize"] = 30;
G2L["2"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2"]["BackgroundColor3"] = Color3.fromRGB(182, 186, 186);
G2L["2"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["2"]["Size"] = UDim2.new(0, 201, 0, 54);
G2L["2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2"]["Text"] = [[Sigma Jello 5.0]];
G2L["2"]["Name"] = [[OpenClose]];
G2L["2"]["Position"] = UDim2.new(0.65636, 0, 0, 0);


-- StarterGui.GUI.OpenClose.UICorner
G2L["3"] = Instance.new("UICorner", G2L["2"]);



-- StarterGui.GUI.OpenClose.LocalScript
G2L["4"] = Instance.new("LocalScript", G2L["2"]);



-- StarterGui.GUI.Frame
G2L["5"] = Instance.new("Frame", G2L["1"]);
G2L["5"]["Active"] = true;
G2L["5"]["BorderSizePixel"] = 0;
G2L["5"]["BackgroundColor3"] = Color3.fromRGB(32, 42, 53);
G2L["5"]["Size"] = UDim2.new(0, 382, 0, 459);
G2L["5"]["Position"] = UDim2.new(0.25036, 0, 0.17066, 0);
G2L["5"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.GUI.Frame.TextLabel
G2L["6"] = Instance.new("TextLabel", G2L["5"]);
G2L["6"]["TextWrapped"] = true;
G2L["6"]["BorderSizePixel"] = 0;
G2L["6"]["TextSize"] = 14;
G2L["6"]["TextScaled"] = true;
G2L["6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["6"]["TextColor3"] = Color3.fromRGB(0, 255, 29);
G2L["6"]["BackgroundTransparency"] = 1;
G2L["6"]["RichText"] = true;
G2L["6"]["Size"] = UDim2.new(0, 159, 0, 50);
G2L["6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6"]["Text"] = [[Sigma Jello 5.0]];


-- StarterGui.GUI.Frame.UICorner
G2L["7"] = Instance.new("UICorner", G2L["5"]);



-- StarterGui.GUI.Frame.Disabler
G2L["8"] = Instance.new("TextButton", G2L["5"]);
G2L["8"]["TextWrapped"] = true;
G2L["8"]["BorderSizePixel"] = 0;
G2L["8"]["TextSize"] = 33;
G2L["8"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8"]["Size"] = UDim2.new(0, 120, 0, 41);
G2L["8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8"]["Text"] = [[Disabler]];
G2L["8"]["Name"] = [[Disabler]];
G2L["8"]["Position"] = UDim2.new(0.04135, 0, 0.65247, 0);


-- StarterGui.GUI.Frame.Disabler.UICorner
G2L["9"] = Instance.new("UICorner", G2L["8"]);



-- StarterGui.GUI.Frame.Disabler.LocalScript
G2L["a"] = Instance.new("LocalScript", G2L["8"]);



-- StarterGui.GUI.Frame.Disabler.Config
G2L["b"] = Instance.new("Folder", G2L["8"]);
G2L["b"]["Name"] = [[Config]];


-- StarterGui.GUI.Frame.Disabler.Config.Active
G2L["c"] = Instance.new("BoolValue", G2L["b"]);
G2L["c"]["Name"] = [[Active]];


-- StarterGui.GUI.Frame.Disabler.Config.Mode
G2L["d"] = Instance.new("StringValue", G2L["b"]);
G2L["d"]["Name"] = [[Mode]];
G2L["d"]["Value"] = [[Local]];


-- StarterGui.GUI.Frame.Config
G2L["e"] = Instance.new("Frame", G2L["5"]);
G2L["e"]["BorderSizePixel"] = 0;
G2L["e"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["e"]["Size"] = UDim2.new(0, 206, 0, 324);
G2L["e"]["Position"] = UDim2.new(0.41458, 0, 0.24942, 0);
G2L["e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e"]["Name"] = [[Config]];
G2L["e"]["BackgroundTransparency"] = 0.3;


-- StarterGui.GUI.Frame.Config.UICorner
G2L["f"] = Instance.new("UICorner", G2L["e"]);



-- StarterGui.GUI.Frame.Config.UIListLayout
G2L["10"] = Instance.new("UIListLayout", G2L["e"]);
G2L["10"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.GUI.Frame.Speed
G2L["11"] = Instance.new("TextButton", G2L["5"]);
G2L["11"]["TextWrapped"] = true;
G2L["11"]["BorderSizePixel"] = 0;
G2L["11"]["TextSize"] = 33;
G2L["11"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["11"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["11"]["Size"] = UDim2.new(0, 110, 0, 41);
G2L["11"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["11"]["Text"] = [[Speed]];
G2L["11"]["Name"] = [[Speed]];
G2L["11"]["Position"] = UDim2.new(0.04236, 0, 0.75759, 0);


-- StarterGui.GUI.Frame.Speed.UICorner
G2L["12"] = Instance.new("UICorner", G2L["11"]);



-- StarterGui.GUI.Frame.Speed.LocalScript
G2L["13"] = Instance.new("LocalScript", G2L["11"]);



-- StarterGui.GUI.Frame.Speed.Config
G2L["14"] = Instance.new("Folder", G2L["11"]);
G2L["14"]["Name"] = [[Config]];


-- StarterGui.GUI.Frame.Speed.Config.Active
G2L["15"] = Instance.new("BoolValue", G2L["14"]);
G2L["15"]["Name"] = [[Active]];


-- StarterGui.GUI.Frame.Speed.Config.Mode
G2L["16"] = Instance.new("StringValue", G2L["14"]);
G2L["16"]["Name"] = [[Mode]];
G2L["16"]["Value"] = [[Local]];


-- StarterGui.GUI.Frame.Fly
G2L["17"] = Instance.new("TextButton", G2L["5"]);
G2L["17"]["TextWrapped"] = true;
G2L["17"]["BorderSizePixel"] = 0;
G2L["17"]["TextSize"] = 33;
G2L["17"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["17"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["17"]["Size"] = UDim2.new(0, 110, 0, 41);
G2L["17"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["17"]["Text"] = [[Flight]];
G2L["17"]["Name"] = [[Fly]];
G2L["17"]["Position"] = UDim2.new(0.04236, 0, 0.86537, 0);


-- StarterGui.GUI.Frame.Fly.UICorner
G2L["18"] = Instance.new("UICorner", G2L["17"]);



-- StarterGui.GUI.Frame.Fly.LocalScript
G2L["19"] = Instance.new("LocalScript", G2L["17"]);



-- StarterGui.GUI.Frame.Fly.Config
G2L["1a"] = Instance.new("Folder", G2L["17"]);
G2L["1a"]["Name"] = [[Config]];


-- StarterGui.GUI.Frame.Fly.Config.Active
G2L["1b"] = Instance.new("BoolValue", G2L["1a"]);
G2L["1b"]["Name"] = [[Active]];


-- StarterGui.GUI.Frame.Fly.Config.Mode
G2L["1c"] = Instance.new("StringValue", G2L["1a"]);
G2L["1c"]["Name"] = [[Mode]];
G2L["1c"]["Value"] = [[Local]];


-- StarterGui.GUI.Frame.disableer2
G2L["1d"] = Instance.new("TextButton", G2L["5"]);
G2L["1d"]["TextWrapped"] = true;
G2L["1d"]["BorderSizePixel"] = 0;
G2L["1d"]["TextSize"] = 33;
G2L["1d"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["1d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["1d"]["Size"] = UDim2.new(0, 256, 0, 37);
G2L["1d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["1d"]["Text"] = [[Disabler [ADVANCED]]];
G2L["1d"]["Name"] = [[disableer2]];
G2L["1d"]["Position"] = UDim2.new(0.04003, 0, 0.13903, 0);


-- StarterGui.GUI.Frame.disableer2.UICorner
G2L["1e"] = Instance.new("UICorner", G2L["1d"]);



-- StarterGui.GUI.Frame.disableer2.LocalScript
G2L["1f"] = Instance.new("LocalScript", G2L["1d"]);



-- StarterGui.GUI.Frame.disableer2.LocalScript.DelScript
G2L["20"] = Instance.new("LocalScript", G2L["1f"]);
G2L["20"]["Enabled"] = false;
G2L["20"]["Name"] = [[DelScript]];
G2L["20"]["Disabled"] = true;


-- StarterGui.GUI.Frame.disableer2.Config
G2L["21"] = Instance.new("Folder", G2L["1d"]);
G2L["21"]["Name"] = [[Config]];


-- StarterGui.GUI.Frame.disableer2.Config.Active
G2L["22"] = Instance.new("BoolValue", G2L["21"]);
G2L["22"]["Name"] = [[Active]];


-- StarterGui.GUI.Frame.disableer2.Config.Mode
G2L["23"] = Instance.new("StringValue", G2L["21"]);
G2L["23"]["Name"] = [[Mode]];
G2L["23"]["Value"] = [[Local]];


-- StarterGui.GUI.Frame.noclip
G2L["24"] = Instance.new("TextButton", G2L["5"]);
G2L["24"]["TextWrapped"] = true;
G2L["24"]["BorderSizePixel"] = 0;
G2L["24"]["TextSize"] = 33;
G2L["24"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["24"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["24"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["24"]["Size"] = UDim2.new(0, 110, 0, 41);
G2L["24"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["24"]["Text"] = [[Phase]];
G2L["24"]["Name"] = [[noclip]];
G2L["24"]["Position"] = UDim2.new(0.03974, 0, 0.53858, 0);


-- StarterGui.GUI.Frame.noclip.UICorner
G2L["25"] = Instance.new("UICorner", G2L["24"]);



-- StarterGui.GUI.Frame.noclip.LocalScript
G2L["26"] = Instance.new("LocalScript", G2L["24"]);



-- StarterGui.GUI.Frame.noclip.Config
G2L["27"] = Instance.new("Folder", G2L["24"]);
G2L["27"]["Name"] = [[Config]];


-- StarterGui.GUI.Frame.noclip.Config.Active
G2L["28"] = Instance.new("BoolValue", G2L["27"]);
G2L["28"]["Name"] = [[Active]];


-- StarterGui.GUI.Frame.noclip.Config.Mode
G2L["29"] = Instance.new("StringValue", G2L["27"]);
G2L["29"]["Name"] = [[Mode]];
G2L["29"]["Value"] = [[Local]];


-- StarterGui.GUI.Frame.Best GUI Drag
G2L["2a"] = Instance.new("LocalScript", G2L["5"]);
G2L["2a"]["Name"] = [[Best GUI Drag]];


-- StarterGui.GUI.Frame.swim
G2L["2b"] = Instance.new("TextButton", G2L["5"]);
G2L["2b"]["TextWrapped"] = true;
G2L["2b"]["BorderSizePixel"] = 0;
G2L["2b"]["TextSize"] = 33;
G2L["2b"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2b"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["2b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["2b"]["Size"] = UDim2.new(0, 110, 0, 41);
G2L["2b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2b"]["Text"] = [[Swim]];
G2L["2b"]["Name"] = [[swim]];
G2L["2b"]["Position"] = UDim2.new(0.03974, 0, 0.42311, 0);


-- StarterGui.GUI.Frame.swim.UICorner
G2L["2c"] = Instance.new("UICorner", G2L["2b"]);



-- StarterGui.GUI.Frame.swim.LocalScript
G2L["2d"] = Instance.new("LocalScript", G2L["2b"]);



-- StarterGui.GUI.Frame.swim.Config
G2L["2e"] = Instance.new("Folder", G2L["2b"]);
G2L["2e"]["Name"] = [[Config]];


-- StarterGui.GUI.Frame.swim.Config.Active
G2L["2f"] = Instance.new("BoolValue", G2L["2e"]);
G2L["2f"]["Name"] = [[Active]];


-- StarterGui.GUI.Frame.swim.Config.Mode
G2L["30"] = Instance.new("StringValue", G2L["2e"]);
G2L["30"]["Name"] = [[Mode]];
G2L["30"]["Value"] = [[Local]];


-- StarterGui.GUI.Notifies
G2L["31"] = Instance.new("Frame", G2L["1"]);
G2L["31"]["BorderSizePixel"] = 0;
G2L["31"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["31"]["Size"] = UDim2.new(0, 270, 0, 629);
G2L["31"]["Position"] = UDim2.new(0.78807, 0, 0.04121, 0);
G2L["31"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["31"]["Name"] = [[Notifies]];
G2L["31"]["BackgroundTransparency"] = 1;


-- StarterGui.GUI.Notifies.UIListLayout
G2L["32"] = Instance.new("UIListLayout", G2L["31"]);
G2L["32"]["HorizontalAlignment"] = Enum.HorizontalAlignment.Right;
G2L["32"]["Padding"] = UDim.new(0, 5);
G2L["32"]["VerticalAlignment"] = Enum.VerticalAlignment.Bottom;
G2L["32"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.GUI.Notifies.Notification
G2L["33"] = Instance.new("ModuleScript", G2L["31"]);
G2L["33"]["Name"] = [[Notification]];


-- StarterGui.GUI.Notifies.Notification.NotificationTemplate
G2L["34"] = Instance.new("Frame", G2L["33"]);
G2L["34"]["BorderSizePixel"] = 0;
G2L["34"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["34"]["Size"] = UDim2.new(0, 227, 0, 99);
G2L["34"]["Position"] = UDim2.new(0.04418, 0, 0.09677, 0);
G2L["34"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["34"]["Name"] = [[NotificationTemplate]];


-- StarterGui.GUI.Notifies.Notification.NotificationTemplate.UIGradient
G2L["35"] = Instance.new("UIGradient", G2L["34"]);
G2L["35"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(125, 174, 255)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(64, 255, 137))};


-- StarterGui.GUI.Notifies.Notification.NotificationTemplate.TextLabel
G2L["36"] = Instance.new("TextLabel", G2L["34"]);
G2L["36"]["TextWrapped"] = true;
G2L["36"]["BorderSizePixel"] = 0;
G2L["36"]["TextSize"] = 14;
G2L["36"]["TextScaled"] = true;
G2L["36"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["36"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["36"]["TextColor3"] = Color3.fromRGB(36, 36, 36);
G2L["36"]["BackgroundTransparency"] = 1;
G2L["36"]["Size"] = UDim2.new(0, 227, 0, 99);
G2L["36"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["36"]["Text"] = [[Test Notification]];


-- StarterGui.GUI.Notifies.Notification.NotificationTemplate.UICorner
G2L["37"] = Instance.new("UICorner", G2L["34"]);
G2L["37"]["CornerRadius"] = UDim.new(0, 25);


-- StarterGui.GUI.AdvanceFly
G2L["38"] = Instance.new("Frame", G2L["1"]);
G2L["38"]["Visible"] = false;
G2L["38"]["Active"] = true;
G2L["38"]["BorderSizePixel"] = 0;
G2L["38"]["BackgroundColor3"] = Color3.fromRGB(42, 42, 43);
G2L["38"]["Size"] = UDim2.new(0, 274, 0, 295);
G2L["38"]["Position"] = UDim2.new(0.71054, 0, 0.1355, 0);
G2L["38"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["38"]["Name"] = [[AdvanceFly]];


-- StarterGui.GUI.AdvanceFly.Flight
G2L["39"] = Instance.new("TextLabel", G2L["38"]);
G2L["39"]["TextWrapped"] = true;
G2L["39"]["BorderSizePixel"] = 0;
G2L["39"]["TextSize"] = 14;
G2L["39"]["TextScaled"] = true;
G2L["39"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["39"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["39"]["TextColor3"] = Color3.fromRGB(0, 255, 29);
G2L["39"]["BackgroundTransparency"] = 1;
G2L["39"]["RichText"] = true;
G2L["39"]["Size"] = UDim2.new(0, 159, 0, 50);
G2L["39"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["39"]["Text"] = [[Flight]];
G2L["39"]["Name"] = [[Flight]];
G2L["39"]["Position"] = UDim2.new(0.18248, 0, 0, 0);


-- StarterGui.GUI.AdvanceFly.UICorner
G2L["3a"] = Instance.new("UICorner", G2L["38"]);



-- StarterGui.GUI.AdvanceFly.UP
G2L["3b"] = Instance.new("TextButton", G2L["38"]);
G2L["3b"]["TextWrapped"] = true;
G2L["3b"]["BorderSizePixel"] = 0;
G2L["3b"]["TextSize"] = 33;
G2L["3b"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3b"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["3b"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3b"]["Size"] = UDim2.new(0, 116, 0, 45);
G2L["3b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3b"]["Text"] = [[UP]];
G2L["3b"]["Name"] = [[UP]];
G2L["3b"]["Position"] = UDim2.new(0.02412, 0, 0.16715, 0);


-- StarterGui.GUI.AdvanceFly.UP.UICorner
G2L["3c"] = Instance.new("UICorner", G2L["3b"]);



-- StarterGui.GUI.AdvanceFly.UP.LocalScript
G2L["3d"] = Instance.new("LocalScript", G2L["3b"]);



-- StarterGui.GUI.AdvanceFly.DOWN
G2L["3e"] = Instance.new("TextButton", G2L["38"]);
G2L["3e"]["TextWrapped"] = true;
G2L["3e"]["BorderSizePixel"] = 0;
G2L["3e"]["TextSize"] = 33;
G2L["3e"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e"]["BackgroundColor3"] = Color3.fromRGB(152, 152, 155);
G2L["3e"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3e"]["Size"] = UDim2.new(0, 116, 0, 45);
G2L["3e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3e"]["Text"] = [[DOWN]];
G2L["3e"]["Name"] = [[DOWN]];
G2L["3e"]["Position"] = UDim2.new(0.49492, 0, 0.16936, 0);


-- StarterGui.GUI.AdvanceFly.DOWN.UICorner
G2L["3f"] = Instance.new("UICorner", G2L["3e"]);



-- StarterGui.GUI.AdvanceFly.DOWN.LocalScript
G2L["40"] = Instance.new("LocalScript", G2L["3e"]);



-- StarterGui.GUI.AdvanceFly.speedText
G2L["41"] = Instance.new("TextLabel", G2L["38"]);
G2L["41"]["TextWrapped"] = true;
G2L["41"]["BorderSizePixel"] = 0;
G2L["41"]["TextSize"] = 14;
G2L["41"]["TextScaled"] = true;
G2L["41"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["41"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["41"]["TextColor3"] = Color3.fromRGB(0, 255, 29);
G2L["41"]["BackgroundTransparency"] = 1;
G2L["41"]["RichText"] = true;
G2L["41"]["Size"] = UDim2.new(0, 245, 0, 50);
G2L["41"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["41"]["Text"] = [[Tower Speed:]];
G2L["41"]["Name"] = [[speedText]];
G2L["41"]["Position"] = UDim2.new(0.02555, 0, 0.34879, 0);


-- StarterGui.GUI.AdvanceFly.speed
G2L["42"] = Instance.new("TextBox", G2L["38"]);
G2L["42"]["Name"] = [[speed]];
G2L["42"]["BorderSizePixel"] = 0;
G2L["42"]["TextWrapped"] = true;
G2L["42"]["TextSize"] = 14;
G2L["42"]["TextDirection"] = Enum.TextDirection.RightToLeft;
G2L["42"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42"]["TextScaled"] = true;
G2L["42"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["42"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["42"]["PlaceholderText"] = [[Speed]];
G2L["42"]["Size"] = UDim2.new(0, 240, 0, 55);
G2L["42"]["Position"] = UDim2.new(0.06069, 0, 0.54461, 0);
G2L["42"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["42"]["Text"] = [[0.4]];
G2L["42"]["BackgroundTransparency"] = 1;


-- StarterGui.GUI.AdvanceFly.disable
G2L["43"] = Instance.new("TextButton", G2L["38"]);
G2L["43"]["TextWrapped"] = true;
G2L["43"]["BorderSizePixel"] = 0;
G2L["43"]["TextSize"] = 33;
G2L["43"]["TextScaled"] = true;
G2L["43"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["43"]["BackgroundColor3"] = Color3.fromRGB(171, 106, 102);
G2L["43"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["43"]["Size"] = UDim2.new(0, 232, 0, 49);
G2L["43"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["43"]["Text"] = [[DISABLE]];
G2L["43"]["Name"] = [[disable]];
G2L["43"]["Position"] = UDim2.new(0.07157, 0, 0.76831, 0);


-- StarterGui.GUI.AdvanceFly.disable.UICorner
G2L["44"] = Instance.new("UICorner", G2L["43"]);



-- StarterGui.GUI.AdvanceFly.disable.LocalScript
G2L["45"] = Instance.new("LocalScript", G2L["43"]);



-- StarterGui.GUI.AdvanceFly.Best GUI Drag
G2L["46"] = Instance.new("LocalScript", G2L["38"]);
G2L["46"]["Name"] = [[Best GUI Drag]];


-- StarterGui.GUI.Disabling
G2L["47"] = Instance.new("Frame", G2L["1"]);
G2L["47"]["Visible"] = false;
G2L["47"]["Active"] = true;
G2L["47"]["BorderSizePixel"] = 0;
G2L["47"]["BackgroundColor3"] = Color3.fromRGB(42, 42, 43);
G2L["47"]["Size"] = UDim2.new(0, 274, 0, 295);
G2L["47"]["Position"] = UDim2.new(0.7186, 0, 0.1355, 0);
G2L["47"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["47"]["Name"] = [[Disabling]];


-- StarterGui.GUI.Disabling.ScrollingFrame
G2L["48"] = Instance.new("ScrollingFrame", G2L["47"]);
G2L["48"]["Active"] = true;
G2L["48"]["BorderSizePixel"] = 0;
G2L["48"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["48"]["Size"] = UDim2.new(0, 250, 0, 201);
G2L["48"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["48"]["Position"] = UDim2.new(0.04745, 0, 0.04068, 0);
G2L["48"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);


-- StarterGui.GUI.Disabling.ScrollingFrame.UIListLayout
G2L["49"] = Instance.new("UIListLayout", G2L["48"]);
G2L["49"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.GUI.Disabling.TextButton
G2L["4a"] = Instance.new("TextButton", G2L["47"]);
G2L["4a"]["TextWrapped"] = true;
G2L["4a"]["BorderSizePixel"] = 0;
G2L["4a"]["TextSize"] = 14;
G2L["4a"]["TextScaled"] = true;
G2L["4a"]["TextColor3"] = Color3.fromRGB(255, 0, 18);
G2L["4a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4a"]["Size"] = UDim2.new(0, 249, 0, 50);
G2L["4a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4a"]["Text"] = [[X]];
G2L["4a"]["Position"] = UDim2.new(0.04745, 0, 0.77627, 0);


-- StarterGui.GUI.Disabling.TextButton.LocalScript
G2L["4b"] = Instance.new("LocalScript", G2L["4a"]);



-- StarterGui.GUI.LocalScript
G2L["4c"] = Instance.new("LocalScript", G2L["1"]);



-- StarterGui.GUI.Resources
G2L["4d"] = Instance.new("Folder", G2L["1"]);
G2L["4d"]["Name"] = [[Resources]];


-- StarterGui.GUI.Resources.LaserScript
G2L["4e"] = Instance.new("LocalScript", G2L["4d"]);
G2L["4e"]["Name"] = [[LaserScript]];


-- Require G2L wrapper
local G2L_REQUIRE = require;
local G2L_MODULES = {};
local function require(Module:ModuleScript)
    local ModuleState = G2L_MODULES[Module];
    if ModuleState then
        if not ModuleState.Required then
            ModuleState.Required = true;
            ModuleState.Value = ModuleState.Closure();
        end
        return ModuleState.Value;
    end;
    return G2L_REQUIRE(Module);
end

G2L_MODULES[G2L["33"]] = {
Closure = function()
    local script = G2L["33"];local TweenService = game:GetService("TweenService")
local players = game:GetService("Players")

local plr = game.Players.LocalPlayer

local notificationTemplate = script:WaitForChild("NotificationTemplate")
local orgSize = notificationTemplate.Size

local module = {}

function module.Notify(text,duration)
	local newNotif = notificationTemplate:Clone()
	newNotif.Size = UDim2.fromScale(0,0)
	
	newNotif.BackgroundTransparency = 1
	newNotif.TextLabel.Transparency = 1
	newNotif.TextLabel.Text = text
	
	newNotif.Parent = script.Parent
	
	TweenService:Create(newNotif,TweenInfo.new(0.6),{BackgroundTransparency = 0}):Play()
	TweenService:Create(newNotif.TextLabel,TweenInfo.new(1), {TextTransparency = 0}):Play()
	
	TweenService:Create(newNotif,TweenInfo.new(0.4,Enum.EasingStyle.Sine,Enum.EasingDirection.Out), {Size = orgSize}):Play()
	
	task.wait(duration)
	
	TweenService:Create(newNotif,TweenInfo.new(0.6),{BackgroundTransparency = 1}):Play()
	TweenService:Create(newNotif.TextLabel,TweenInfo.new(1), {TextTransparency = 1}):Play()

	TweenService:Create(newNotif,TweenInfo.new(0.7,Enum.EasingStyle.Sine,Enum.EasingDirection.Out), {Size = UDim2.fromScale(0,0)}):Play()
	
	task.wait(1)
	
	newNotif:Destroy() 
end

return module

end;
};
-- StarterGui.GUI.OpenClose.LocalScript
local function C_4()
local script = G2L["4"];
	script.Parent.Parent:WaitForChild("Frame").Draggable = true
	script.Parent.Parent.Frame.Config.Visible = false
	script.Parent.MouseButton1Click:Connect(function()
		if script.Parent.Parent.Frame.Visible == false then
			script.Parent.Parent.Frame.Visible = true
		else
			script.Parent.Parent.Frame.Visible = false
		end
	end)
end;
task.spawn(C_4);
-- StarterGui.GUI.Frame.Disabler.LocalScript
local function C_a()
local script = G2L["a"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Config.Visible = false
		if script.Parent.Config.Mode.Value == "Local" then
			for _, src in ipairs(game.Players.LocalPlayer.Character:GetChildren()) do
				if src.ClassName == "LocalScript" then
					if src.Name ~= "Animate" then
						src.Enabled = false
					end
				end
			end
			local notifClient = require(script.Parent.Parent.Parent.Notifies.Notification)
			notifClient.Notify("All Local Character Scripts have been disabled",3)
		end
	end)
	
end;
task.spawn(C_a);
-- StarterGui.GUI.Frame.Speed.LocalScript
local function C_13()
local script = G2L["13"];
	script.Parent.MouseButton1Click:Connect(function()
		local notif = require(script.Parent.Parent.Parent.Notifies.Notification)
	
		-- Clear previous config
		for _, x in ipairs(script.Parent.Parent.Config:GetChildren()) do
			x:Destroy()
		end
	
		-- Common UI Settings
		local function createButton(name, text, position)
			local btn = Instance.new("TextButton")
			btn.Name = name
			btn.Parent = script.Parent.Parent.Config
			btn.Active = false
			btn.BackgroundColor3 = Color3.fromRGB(86, 223, 96)
			btn.BorderSizePixel = 0
			btn.Position = position
			btn.Size = UDim2.new(0, 175, 0, 50)
			btn.Font = Enum.Font.SourceSans
			btn.Text = text
			btn.TextColor3 = Color3.fromRGB(0, 0, 0)
			btn.TextSize = 35
			btn.TextWrapped = true
			return btn
		end
	
		local walkSpeedBtn = createButton("WalkSpeedBtn", "WalkSpeed", UDim2.new(0, 0, 0.2, 0))
		local physicsBtn = createButton("PhysicsBtn", "Physics", UDim2.new(0, 0, 0.45, 0))
	
		local textBox = Instance.new("TextBox")
		textBox.Parent = script.Parent.Parent.Config
		textBox.BackgroundTransparency = 1
		textBox.Size = UDim2.new(0, 175, 0, 50)
		textBox.Font = Enum.Font.SourceSans
		textBox.Text = "16"
		textBox.TextColor3 = Color3.fromRGB(0, 0, 0)
		textBox.TextScaled = true
		textBox.TextWrapped = true
	
		script.Parent.Parent.Config.Visible = true
	
		local modeValue = script.Parent.Config.Mode
	
		-- Disconnect previous physics connection
		if _G.physicsMoveConn then
			_G.physicsMoveConn:Disconnect()
			_G.physicsMoveConn = nil
		end
	
		-- Reset WalkSpeed
		local function resetWalkSpeed()
			local hum = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
			if hum then hum.WalkSpeed = 16 end
		end
	
		-- WalkSpeed toggle
		local walkEnabled = false
		walkSpeedBtn.MouseButton1Click:Connect(function()
			local hum = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
			if walkEnabled then
				resetWalkSpeed()
				modeValue.Value = ""
				walkEnabled = false
				notif.Notify("WalkSpeed Disabled")
			else
				local speed = tonumber(textBox.Text) or 16
				hum.WalkSpeed = speed
				modeValue.Value = "WalkSpeed"
				walkEnabled = true
				notif.Notify("WalkSpeed Enabled")
			end
		end)
	
		-- Physics toggle
		local physicsEnabled = false
		local RunService = game:GetService("RunService")
	
		physicsBtn.MouseButton1Click:Connect(function()
			local player = game.Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:Wait()
			local hrp = char:WaitForChild("HumanoidRootPart")
	
			if physicsEnabled then
				if _G.physicsMoveConn then
					_G.physicsMoveConn:Disconnect()
					_G.physicsMoveConn = nil
				end
				modeValue.Value = ""
				physicsEnabled = false
				notif.Notify("Physics Movement Disabled")
			else
				local speed = tonumber(textBox.Text) or 0.5
				modeValue.Value = "Physics"
				physicsEnabled = true
				notif.Notify("Physics Movement Enabled")
	
				_G.physicsMoveConn = RunService.RenderStepped:Connect(function()
					if modeValue.Value ~= "Physics" then return end
					hrp.CFrame = hrp.CFrame + hrp.CFrame.LookVector * speed/90
				end)
			end
		end)
	end)
	
end;
task.spawn(C_13);
-- StarterGui.GUI.Frame.Fly.LocalScript
local function C_19()
local script = G2L["19"];
	local UIS = game:GetService("UserInputService")
	local Humanoid = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
	local hpr = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
	local player = game.Players.LocalPlayer
	local char = player.Character or player.CharacterAdded:Wait()
	local humanoid = char:WaitForChild("Humanoid")
	local root = char:WaitForChild("HumanoidRootPart")
	local notif = require(script.Parent.Parent.Parent.Notifies.Notification)
	local flyBlock = nil
	local newHighlight = nil
	local groupModel = nil
	local hightlightHuman = nil
	
	
	local advancedFlyFrame = script.Parent.Parent.Parent.AdvanceFly
	
	local originalWalkSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower
	
	local isFlyingJumpMode = false -- Flag for Jump/Fall Spoof mode
	
	local function notifyAsync(message, duration)
		spawn(function()
			notif.Notify(message, duration)
		end)
	end
	
	script.Parent.MouseButton1Click:Connect(function()
	
		for i, x in ipairs(script.Parent.Parent.Config:GetChildren()) do
			x:Destroy()
		end
	
		local UIListLayout = Instance.new("UIListLayout")
		UIListLayout.Parent = script.Parent.Parent.Config
		UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		local UICorner = Instance.new("UICorner")
		UICorner.Parent = script.Parent.Parent.Config
	
		local TextBut1 = Instance.new("TextButton")
		TextBut1.Parent = script.Parent.Parent.Config
		TextBut1.Active = false
		TextBut1.BackgroundColor3 = Color3.fromRGB(86, 223, 96)
		TextBut1.BorderColor3 = Color3.fromRGB(0, 0, 0)
		TextBut1.BorderSizePixel = 0
		TextBut1.Size = UDim2.new(0, 175, 0, 50)
		TextBut1.Font = Enum.Font.SourceSans
		TextBut1.Text = "Fall Spoof"
		TextBut1.TextColor3 = Color3.fromRGB(0, 0, 0)
		TextBut1.TextSize = 35.000
		TextBut1.TextWrapped = true
		TextBut1.Name = "Jump"
		TextBut1.TextScaled = true
	
		local TextBut2 = Instance.new("TextButton")
		TextBut2.Parent = script.Parent.Parent.Config
		TextBut2.Active = false
		TextBut2.BackgroundColor3 = Color3.fromRGB(86, 223, 96)
		TextBut2.BorderColor3 = Color3.fromRGB(0, 0, 0)
		TextBut2.BorderSizePixel = 0
		TextBut2.Size = UDim2.new(0, 175, 0, 50)
		TextBut2.Font = Enum.Font.SourceSans
		TextBut2.Text = "Platform"
		TextBut2.TextColor3 = Color3.fromRGB(0, 0, 0)
		TextBut2.TextSize = 35.000
		TextBut2.TextWrapped = true
		TextBut2.Name = "Advanced"
		TextBut2.TextScaled = true
	
		script.Parent.Parent.Config.Visible = true
	
		TextBut1.MouseButton1Click:Connect(function()
			if _G.jumpFly == nil then
				_G.jumpFly = true
				isFlyingJumpMode = true
				_G.realFly = nil
				script.Parent.Config.Mode.Value = "Jump"
				notifyAsync("Activated Fly:Jump", 1.5)
	
				-- Restore initial properties that were changed for PlatformStand
				humanoid.PlatformStand = false -- Ensure this is off
				humanoid.WalkSpeed = 15 -- Slight reduction for horizontal speed safety
				humanoid.JumpPower = 100 -- Set JumpPower to 100 for vertical ascent
				humanoid.UseJumpPower = true 
	
				-- No BodyVelocity needed for this jump-based vertical movement
				-- Ensure no lingering BodyVelocity from previous attempts
				if root:FindFirstChild("BodyVelocity") then
					root.BodyVelocity:Destroy()
				end
	
				-- Input handling for movement
				local currentMoveVector = Vector3.new(0,0,0)
	
				local function updateMoveVector()
					currentMoveVector = Vector3.new(0, 0, 0)
	
					if UIS:IsKeyDown(Enum.KeyCode.W) then
						currentMoveVector = currentMoveVector + Vector3.new(0, 0, -1)
					end
					if UIS:IsKeyDown(Enum.KeyCode.S) then
						currentMoveVector = currentMoveVector + Vector3.new(0, 0, 1)
					end
					if UIS:IsKeyDown(Enum.KeyCode.A) then
						currentMoveVector = currentMoveVector + Vector3.new(-1, 0, 0)
					end
					if UIS:IsKeyDown(Enum.KeyCode.D) then
						currentMoveVector = currentMoveVector + Vector3.new(1, 0, 0)
					end
	
					if currentMoveVector.magnitude > 0 then
						currentMoveVector = currentMoveVector.unit -- Normalize for consistent speed
					end
				end
	
				-- Connections to update move vector on input changes
				local inputChangedConnection = UIS.InputBegan:Connect(function(input, processed)
					if processed then return end
					updateMoveVector()
				end)
				local inputEndedConnection = UIS.InputEnded:Connect(function(input)
					updateMoveVector()
				end)
	
				-- Main movement loop (Humanoid:Move() for horizontal, Jump for vertical)
				local moveLoopConnection
				moveLoopConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
					if isFlyingJumpMode then
						-- Horizontal Movement with Humanoid:Move()
						local cameraRelativeVector = workspace.CurrentCamera.CFrame:VectorToWorldSpace(currentMoveVector)
						humanoid:Move(cameraRelativeVector * humanoid.WalkSpeed) -- Uses current (adjusted) WalkSpeed
	
						-- Vertical Movement: Repeated Jumps for 'E', Freefall for 'Q'
						if UIS:IsKeyDown(Enum.KeyCode.E) then
							if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
								humanoid:ChangeState(Enum.HumanoidStateType.Jumping) -- Trigger jump if not already jumping
							end
						elseif UIS:IsKeyDown(Enum.KeyCode.Q) then
							humanoid:ChangeState(Enum.HumanoidStateType.Freefall) -- Allows natural falling
						else
							-- When no vertical key is pressed, keep jumping to stay airborne / reset JumpTime
							-- This is the fall-back for maintaining air time
							if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
								humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
							end
						end
	
						-- Ensure the humanoid is not in a seated state unless specifically spoofing
						if humanoid:GetState() == Enum.HumanoidStateType.Seated then
							humanoid.Sit = false
							humanoid:ChangeState(Enum.HumanoidStateType.Jumping) -- Immediately jump out of seated state
						end
	
					else
						if moveLoopConnection then moveLoopConnection:Disconnect() end
					end
				end)
	
				-- Seated State Spoofing (CRITICAL for Flight Jump time reset)
				local seatedSpoofConnection
				seatedSpoofConnection = game:GetService("RunService").Heartbeat:Connect(function()
					if isFlyingJumpMode then
						-- Trigger seated spoof every 1.5 seconds, for a very brief moment
						if math.fmod(tick(), 1.5) < 0.1 then -- Slightly less frequent than 1 sec to see impact
							humanoid.Sit = true
							task.wait(0.05) 
							humanoid.Sit = false
							humanoid:ChangeState(Enum.HumanoidStateType.Jumping) -- Force a jump immediately after unseating
						end
					else
						if seatedSpoofConnection then seatedSpoofConnection:Disconnect() end
					end
				end)
	
				-- Cleanup
				repeat task.wait() until not isFlyingJumpMode 
	
				-- Restore properties and states
				humanoid.PlatformStand = false -- Ensure off
				humanoid.WalkSpeed = originalWalkSpeed
				humanoid.JumpPower = originalJumpPower
				humanoid.Sit = false 
				humanoid:ChangeState(Enum.HumanoidStateType.Running) -- Return to normal state
	
				-- No hoverBodyVel to destroy in this version
	
				-- Disconnect all connections created in this scope
				if moveLoopConnection then moveLoopConnection:Disconnect() end
				if seatedSpoofConnection then seatedSpoofConnection:Disconnect() end
				if inputChangedConnection then inputChangedConnection:Disconnect() end
				if inputEndedConnection then inputEndedConnection:Disconnect() end
	
				notifyAsync("Disabled Fly:Jump", 1.5)
			else
				_G.jumpFly = nil
				isFlyingJumpMode = false 
	
				-- Restore properties and states if toggled off prematurely
				humanoid.PlatformStand = false
				humanoid.WalkSpeed = originalWalkSpeed
				humanoid.JumpPower = originalJumpPower
				humanoid.Sit = false
				humanoid:ChangeState(Enum.HumanoidStateType.Running)
	
				-- No hoverBodyVel to destroy
	
				-- Manual disconnection for robust cleanup
				for _, conn in ipairs(game:GetService("RunService").Heartbeat:GetConnections()) do
					if conn.Connected and tostring(conn.Function):find("isFlyingJumpMode") then
						conn:Disconnect()
					end
				end
				for _, conn in ipairs(UIS.InputBegan:GetConnections()) do
					if conn.Connected and tostring(conn.Function):find("updateMoveVector") then
						conn:Disconnect()
					end
				end
				for _, conn in ipairs(UIS.InputEnded:GetConnections()) do
					if conn.Connected and tostring(conn.Function):find("updateMoveVector") then
						conn:Disconnect()
					end
				end
	
				notifyAsync("Disabled Fly:Jump", 1.5)
			end
		end)
	
	
		TextBut2.MouseButton1Click:Connect(function()
			_G.posY = game.Players.LocalPlayer.Character.HumanoidRootPart.Position.Y
			_G.jumpFly = nil
			isFlyingJumpMode = false 
			if _G.realFly == nil then
				_G.realFly = true
			end
			_G.realFly = true
			script.Parent.Config.Mode.Value = "Float"
	
			-- Ensure original humanoid properties are restored if coming from jump mode
			humanoid.WalkSpeed = originalWalkSpeed
			humanoid.JumpPower = originalJumpPower
			humanoid.PlatformStand = false 
	
			if flyBlock == nil then
				notifyAsync("Activated Fly:Advanced", 1.5)
	
				groupModel = Instance.new("Model")
				groupModel.Parent = game.Workspace
				hightlightHuman = Instance.new("Humanoid")
				hightlightHuman.Parent = groupModel
	
				flyBlock = Instance.new("Part")
				flyBlock.Size = Vector3.new(5, 0.1, 5)
				flyBlock.Color = Color3.new(0.58967, 0.723705, 1)
				flyBlock.Anchored = true
				flyBlock.Transparency = 0.999999
				flyBlock.Parent = game.Workspace
				flyBlock.TopSurface = "Smooth"
				flyBlock.BottomSurface = "Smooth"
				flyBlock.Parent = groupModel
				flyBlock.Material = Enum.Material.Plastic
	
				newHighlight = Instance.new("Highlight")
				newHighlight.FillTransparency = 0.8
				newHighlight.OutlineTransparency = 0
				newHighlight.Parent = groupModel
	
	
				advancedFlyFrame.Visible = true
			else
				groupModel:Destroy()
				flyBlock = nil
				notifyAsync("Disabled Fly:Advanced", 1.5)
				advancedFlyFrame.Visible = false
				return
			end
	
			while _G.realFly == true do
				-- THIS ADVANCED FLY MODE WILL LIKELY BE DETECTED FOR SPEED/NOCLIP DUE TO DIRECT CFRAME MANIPULATION
				-- Consider revising this to use Humanoid:Move() and physics as well.
				local PositionX = game.Players.LocalPlayer.Character.HumanoidRootPart.Position.X
				local PositionZ = game.Players.LocalPlayer.Character.HumanoidRootPart.Position.Z
	
				local newPos = Vector3.new(PositionX, _G.posY - 2.17, PositionZ)
				flyBlock.Position = newPos
				wait()
	
				local speed = advancedFlyFrame.speed.Text
	
				if UIS:IsKeyDown(Enum.KeyCode.E) then
					_G.posY = _G.posY + speed
				end
				if UIS:IsKeyDown(Enum.KeyCode.Q) then
					_G.posY = _G.posY - speed
				end
			end
			groupModel:Destroy()
			flyBlock = nil
			notifyAsync("Disabled Fly:Advanced", 1.5)
			advancedFlyFrame.Visible = false
		end)
	
	end)
end;
task.spawn(C_19);
-- StarterGui.GUI.Frame.disableer2.LocalScript
local function C_1f()
local script = G2L["1f"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Disabling.Visible = true
		for i,x in game:GetService("ReplicatedStorage"):GetDescendants() do
			if x.ClassName == "RemoteEvent" then
				print(x.Name)
				local btn = Instance.new("TextButton")
				local newScript = script.DelScript:Clone()
				newScript.Parent = btn
				btn.Name = "NewRemoteCapture"
				btn.Parent = script.Parent.Parent.Parent.Disabling.ScrollingFrame
				btn.Active = false
				btn.BackgroundColor3 = Color3.fromRGB(86, 223, 96)
				btn.BorderSizePixel = 0
				btn.Size = UDim2.new(0, 175, 0, 50)
				btn.Font = Enum.Font.SourceSans
				btn.Text = x.Name
				btn.TextColor3 = Color3.fromRGB(0, 0, 0)
				btn.TextSize = 35
				btn.TextWrapped = true
				newScript.Enabled = true
			end
		end
	end)
	
end;
task.spawn(C_1f);
-- StarterGui.GUI.Frame.noclip.LocalScript
local function C_26()
local script = G2L["26"];
	local UIS = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Workspace = game:GetService("Workspace")
	local TextChatService = game:GetService("TextChatService")
	
	local player = Players.LocalPlayer
	local notif = require(script.Parent.Parent.Parent.Notifies.Notification)
	local configFolder = script.Parent:WaitForChild("Config") -- Folder
	local guiConfig = script.Parent.Parent.Parent.Frame.Config -- GUI Frame for inputs
	local activeFlag = configFolder:WaitForChild("Active")
	
	local PART_SIZE = 0.5
	local MOVE_STEP = 1
	local MAX_PHASE_ATTEMPTS = 1
	local maxPushDistanceValue = 15
	
	local char, humanoid, root, walkspeed, jumppower
	
	local function notifyAsync(message, duration)
		spawn(function()
			notif.Notify(message, duration)
		end)
	end
	
	local function sendLocalMessage(message)
		TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXSystem"):DisplaySystemMessage(message)
	end
	
	local function updateCharReferences()
		char = player.Character
		if not char then return false end
		humanoid = char:FindFirstChildWhichIsA("Humanoid")
		root = char:FindFirstChild("HumanoidRootPart")
		walkspeed = humanoid.WalkSpeed
		jumppower = humanoid.JumpPower
		return humanoid and root
	end
	
	player.CharacterAdded:Connect(function(character)
		char = character
		humanoid = nil
		root = nil
		humanoid = character:WaitForChild("Humanoid")
		root = character:WaitForChild("HumanoidRootPart")
	end)
	
	local function createSquarePart()
		local part = Instance.new("Part")
		part.Size = Vector3.new(PART_SIZE, PART_SIZE, PART_SIZE)
		part.Shape = Enum.PartType.Block
		part.Material = Enum.Material.Neon
		part.Color = Color3.fromRGB(0, 255, 255)
		part.Transparency = 1
		part.CanCollide = false
		part.Anchored = true
		part.Parent = Workspace
		part.Name = "SpawnedSquare"
		return part
	end
	
	local function isCharStuck()
		if not root then return true end
		local touching = Workspace:GetPartsInPart(root)
		for _, part in ipairs(touching) do
			if part.CanCollide and part.Transparency < 1 and not part:IsDescendantOf(char) then
				return true
			end
		end
		return false
	end
	
	local function phaseThroughWall(spawnCFrame, phaseDirection, maxPhases)
		humanoid.WalkSpeed = 0
		humanoid.JumpPower = 0
		local attempts = 0
		local stuck = true
		local lastCFrame = spawnCFrame
	
		while stuck and attempts < maxPhases do
			local part = createSquarePart()
			part.CFrame = lastCFrame
	
			local currentDistanceMoved = 0
			local lastGoodCFrame = part.CFrame
			local success = false
	
			while currentDistanceMoved < maxPushDistanceValue do
				part.CFrame = part.CFrame + (phaseDirection * MOVE_STEP)
				currentDistanceMoved += MOVE_STEP
				local touchingParts = Workspace:GetPartsInPart(part)
				local collisionDetected = false
	
				for _, p in pairs(touchingParts) do
					if p and p.CanCollide and p.Transparency < 1 then
						collisionDetected = true
						break
					end
				end
	
				if not collisionDetected then
					lastGoodCFrame = part.CFrame
					success = true
					break
				end
	
				RunService.Heartbeat:Wait()
			end
	
			part:Destroy()
	
			if not success then
				notifyAsync("Reached maximum wall distance", 2)
			end
	
			if not char.PrimaryPart or char.PrimaryPart ~= root then
				char.PrimaryPart = root
			end
	
			local finalCFrame = lastGoodCFrame + Vector3.new(0, 2, 0)
			char:SetPrimaryPartCFrame(finalCFrame)
			RunService.Heartbeat:Wait()
	
			stuck = isCharStuck()
			if stuck then
				lastCFrame = lastGoodCFrame + (phaseDirection * MOVE_STEP * 2)
			end
	
			attempts += 1
		end
	
		humanoid.WalkSpeed = walkspeed
		humanoid.JumpPower = jumppower
	end
	
	-- Button click toggles noclip and shows textbox
	script.Parent.MouseButton1Click:Connect(function()
		if activeFlag.Value == true then
			notifyAsync("Phase disabled.", 2)
			activeFlag.Value = false
		else
			notifyAsync("Phase enabled! Press X when looking towards a wall to noclip.", 3)
			activeFlag.Value = true
	
			-- Add push distance textbox if not already present
			if not guiConfig:FindFirstChild("MaxPushBox") then
				local textBox = Instance.new("TextBox")
				textBox.Name = "MaxPushBox"
				textBox.Parent = guiConfig
				textBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				textBox.BorderSizePixel = 0
				textBox.Position = UDim2.new(0, 0, 0.3, 0) -- Adjust for layout
				textBox.Size = UDim2.new(0, 175, 0, 50)
				textBox.Font = Enum.Font.SourceSans
				textBox.Text = tostring(maxPushDistanceValue)
				textBox.TextColor3 = Color3.fromRGB(0, 0, 0)
				textBox.TextScaled = true
				textBox.TextWrapped = true
	
				textBox.FocusLost:Connect(function()
					local val = tonumber(textBox.Text)
					if val and val > 0 and val <= 100 then
						maxPushDistanceValue = val
						notifyAsync("Max push distance set to " .. val, 2)
					else
						textBox.Text = tostring(maxPushDistanceValue)
						notifyAsync("Invalid push distance!", 2)
					end
				end)
			end
	
			guiConfig.Visible = true
		end
	end)
	
	-- Handle input for X key to trigger phase
	UIS.InputBegan:Connect(function(input, gameProcessedEvent)
		if gameProcessedEvent then return end
		if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
	
		if activeFlag.Value == true and input.KeyCode == Enum.KeyCode.X then
			if not updateCharReferences() then return end
	
			local camera = Workspace.CurrentCamera
			local direction = Vector3.new(camera.CFrame.LookVector.X, 0, camera.CFrame.LookVector.Z)
			if direction.Magnitude == 0 then
				notifyAsync("Look forward to phase!", 2)
				return
			end
			direction = direction.Unit
	
			local wallRayParams = RaycastParams.new()
			wallRayParams.FilterType = Enum.RaycastFilterType.Exclude
			wallRayParams.FilterDescendantsInstances = {char}
	
			local rayOrigin = root.Position
			local rayDirection = direction * 20
			local rayResult = Workspace:Raycast(rayOrigin, rayDirection, wallRayParams)
	
			if rayResult then
				local normal = rayResult.Normal
				if math.abs(normal.Y) < 0.5 then
					local wallPoint = rayResult.Position
					local spawnCFrame = CFrame.new(wallPoint - direction * 0.5)
					phaseThroughWall(spawnCFrame, direction, MAX_PHASE_ATTEMPTS)
				else
					notifyAsync("Look at a vertical wall to phase through it!", 2)
				end
			else
				notifyAsync("No wall in front to phase through!", 2)
			end
		end
	end)
	
end;
task.spawn(C_26);
-- StarterGui.GUI.Frame.Best GUI Drag
local function C_2a()
local script = G2L["2a"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (14); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.Visible = true
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_2a);
-- StarterGui.GUI.Frame.swim.LocalScript
local function C_2d()
local script = G2L["2d"];
	local UIS = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Workspace = game:GetService("Workspace")
	local TextChatService = game:GetService("TextChatService")
	local Terrain = Workspace.Terrain -- Get Terrain directly for easier access
	
	local player = Players.LocalPlayer
	local notif = require(script.Parent.Parent.Parent.Notifies.Notification)
	local configFolder = script.Parent:WaitForChild("Config") -- Folder
	local guiConfig = script.Parent.Parent.Parent.Frame.Config -- GUI Frame for inputs
	local activeFlag = configFolder:WaitForChild("Active")
	
	local char -- This 'char' is currently unused, but kept for context if you use it later.
	
	local function notifyAsync(message, duration)
		spawn(function()
			notif.Notify(message, duration)
		end)
	end
	
	local function sendLocalMessage(message)
		TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXSystem"):DisplaySystemMessage(message)
	end
	
	-- Variable to hold the connection for the rainbow effect, so we can disconnect it
	local rainbowConnection
	local currentHue = 0 -- Initialize hue for the rainbow effect
	
	-- Table to store references to active water blobs so they can be cleared
	local activeWaterBlobs = {}
	
	script.Parent.MouseButton1Click:Connect(function()
		local character = player.Character -- Use 'character' to avoid confusion if 'char' is used elsewhere
		if not character or not character.HumanoidRootPart then return end -- Ensure character exists
	
		if activeFlag.Value == true then -- If currently active, disable it
			activeFlag.Value = false
			notifyAsync("Swim Disabled", 1.5)
	
			-- Stop the rainbow effect
			if rainbowConnection then
				rainbowConnection:Disconnect()
				rainbowConnection = nil
			end
	
			-- Immediately clear all remaining water blobs
			for _, blobData in pairs(activeWaterBlobs) do
				Terrain:FillBlock(blobData.cframe, blobData.size, Enum.Material.Air)
			end
			activeWaterBlobs = {} -- Clear the table
	
			-- Reset water properties if you changed them (optional, but good practice)
			Terrain.WaterTransparency = 0.5 -- Default Roblox terrain water transparency
			Terrain.WaterWaveSize = 1 -- Default wave size
			Terrain.WaterWaveSpeed = 100 -- Default wave speed
			-- You might also want to set WaterColor back to a default blue if needed
			-- Terrain.WaterColor = Color3.new(0, 0.4, 0.7) -- Example default blue
	
		else -- If currently inactive, enable it
			activeFlag.Value = true
			notifyAsync("Swim Enabled", 1.5)
	
			-- Set water properties when enabled
			Terrain.WaterTransparency = 0.9 -- Made it more transparent based on your code
			Terrain.WaterWaveSize = 0
			Terrain.WaterWaveSpeed = 0
	
			-- Start the rainbow effect only if it's not already running
			if not rainbowConnection then
				rainbowConnection = RunService.RenderStepped:Connect(function(deltaTime)
					currentHue = (currentHue + deltaTime * 50) % 360
					Terrain.WaterColor = Color3.fromHSV(currentHue / 360, 1, 1)
				end)
			end
	
			-- Loop to create and clear water blocks
			while activeFlag.Value == true do
				task.wait(0.01)
				local position = character.HumanoidRootPart.Position
				local cframe = CFrame.new(position)
				local size = Vector3.new(8,8,8)
	
				-- Fill the block with water
				Terrain:FillBlock(cframe, size, Enum.Material.Water)
	
				-- Add this blob's data to our tracking table
				table.insert(activeWaterBlobs, {cframe = cframe, size = size})
	
				-- Schedule the clearing of the block after 3 seconds
				task.delay(3, function()
					-- Find and remove this specific blob from the tracking table
					for i, blobData in ipairs(activeWaterBlobs) do
						if blobData.cframe == cframe and blobData.size == size then
							table.remove(activeWaterBlobs, i)
							break
						end
					end
					Terrain:FillBlock(cframe, size, Enum.Material.Air)
				end)
			end
			-- If the while loop exits (e.g., due to activeFlag.Value becoming false)
			-- Ensure rainbow effect and any lingering blobs are cleared
			if rainbowConnection then
				rainbowConnection:Disconnect()
				rainbowConnection = nil
			end
			for _, blobData in pairs(activeWaterBlobs) do
				Terrain:FillBlock(blobData.cframe, blobData.size, Enum.Material.Air)
			end
			activeWaterBlobs = {}
			-- Reset water properties after the loop if needed (similar to the disable block)
			Terrain.WaterTransparency = 0.5
			Terrain.WaterWaveSize = 1
			Terrain.WaterWaveSpeed = 100
		end
	end)
end;
task.spawn(C_2d);
-- StarterGui.GUI.AdvanceFly.UP.LocalScript
local function C_3d()
local script = G2L["3d"];
	script.Parent.MouseButton1Click:Connect(function()
		local speed = script.Parent.Parent.speed.Text
		_G.posY = _G.posY + speed
	end)
end;
task.spawn(C_3d);
-- StarterGui.GUI.AdvanceFly.DOWN.LocalScript
local function C_40()
local script = G2L["40"];
	script.Parent.MouseButton1Click:Connect(function()
		local speed = script.Parent.Parent.speed.Text
		_G.posY = _G.posY - speed
	end)
end;
task.spawn(C_40);
-- StarterGui.GUI.AdvanceFly.disable.LocalScript
local function C_45()
local script = G2L["45"];
	script.Parent.MouseButton1Click:Connect(function()
		_G.realFly = false
	end)
end;
task.spawn(C_45);
-- StarterGui.GUI.AdvanceFly.Best GUI Drag
local function C_46()
local script = G2L["46"];
	local UserInputService = game:GetService("UserInputService")
	local runService = (game:GetService("RunService"));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (14); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end;
task.spawn(C_46);
-- StarterGui.GUI.Disabling.TextButton.LocalScript
local function C_4b()
local script = G2L["4b"];
	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Visible = false
	end)
end;
task.spawn(C_4b);
-- StarterGui.GUI.LocalScript
local function C_4c()
local script = G2L["4c"];
	local Players = game:GetService("Players")
	local LocalPlayer = Players.LocalPlayer
	local backpack = LocalPlayer.Backpack
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() -- Get character, or wait for it to load
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local notifyAsync = require(script.Parent:WaitForChild("Notifies"):WaitForChild("Notification"))
	
	local hyperlaserGun = backpack:FindFirstChild("HyperlaserGun") or character:FindFirstChild("HyperlaserGun")
	local classicsword = backpack:FindFirstChild("ClassicSword") or character:FindFirstChild("ClassicSword")
	
	-- Removed MAX_REACH_DISTANCE as you want infinite reach
	local HIT_TELEPORT_OFFSET = Vector3.new(0, 0, -1) -- Small offset for handle to ensure contact.
	local VISIBLE_SWING_RANGE = 8 -- Normal range where sword can visually hit (e.g., 8 studs)
	
	if hyperlaserGun then
		notifyAsync.Notify("Laser Gun Detected! Injecting laser hack...", 3)
	
		if hyperlaserGun:FindFirstChild("ToolScript") then
			hyperlaserGun:FindFirstChild("ToolScript"):Destroy()
	
			local fakescript = script.Parent.Resources:WaitForChild("LaserScript")
			local newfakescript = fakescript:Clone()
			newfakescript.Parent = hyperlaserGun
	
			local starter = game:GetService("StarterPack")
			local newcopy = hyperlaserGun:Clone() -- Clone the existing found gun
	
			if starter:FindFirstChild("HyperlaserGun") then
				starter:FindFirstChild("HyperlaserGun"):Destroy()
				newcopy.Parent = starter
				notifyAsync.Notify("Succesfully injected laser script!", 2)
			else
				notifyAsync.Notify("Could not inject fake laser script. (error 201)", 2)
			end
		else
			notifyAsync.Notify("Could not inject fake laser script. (error 202)", 2)
		end
	end
	
	if classicsword then
		notifyAsync.Notify("Classic Sword Detected! Activating Sword Hack...", 3)
	
		local isSwordEquipped = false
		local swordBehaviorConnection = nil
		local shakeDirection = 1 -- 1 for right, -1 for left
		local shakeMagnitude = math.rad(3) -- 3 degrees in radians for rotation deviation
	
		local lastHitTime = 0 -- To debounce hits on the client side
		local hitCooldown = 0.2 -- Adjust this to match sword swing/hit rate
	
		-- Function to find the closest enemy
		local function findClosestEnemy()
			local closestPlayer = nil
			local shortestDistance = math.huge
			local localCharacter = LocalPlayer.Character
			if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then return nil end
			local localHRP = localCharacter.HumanoidRootPart
	
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
					local enemyHRP = player.Character.HumanoidRootPart
					local distance = (localHRP.Position - enemyHRP.Position).magnitude
					if distance < shortestDistance then
						shortestDistance = distance
						closestPlayer = player
					end
				end
			end
			return closestPlayer
		end
	
		-- Function to handle auto-aim, character rotation shake, and infinite reach
		local function manageSwordBehavior()
			if swordBehaviorConnection then
				swordBehaviorConnection:Disconnect()
			end
	
			swordBehaviorConnection = RunService.RenderStepped:Connect(function()
				if isSwordEquipped and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
					local localHRP = LocalPlayer.Character.HumanoidRootPart
					local swordHandle = classicsword:FindFirstChild("Handle")
	
					if not swordHandle then return end
	
					-- Find closest enemy and aim
					local closestEnemy = findClosestEnemy()
					local targetCFrame = localHRP.CFrame -- Default to current if no enemy
	
					if closestEnemy and closestEnemy.Character and closestEnemy.Character:FindFirstChild("HumanoidRootPart") then
						local enemyHRP = closestEnemy.Character.HumanoidRootPart
						local lookVector = (enemyHRP.Position - localHRP.Position).unit
						lookVector = Vector3.new(lookVector.X, 0, lookVector.Z).unit -- Flatten Y-axis
						targetCFrame = CFrame.new(localHRP.Position, localHRP.Position + lookVector)
	
						local distanceToEnemy = (localHRP.Position - enemyHRP.Position).magnitude
	
						-- === INFINITE REACH LOGIC (Handle Teleport Touch) ===
						-- Condition: Mouse held down, cooldown passed
						if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and (tick() - lastHitTime > hitCooldown) then
							-- Only perform teleport-touch if outside normal swing range
							if distanceToEnemy > VISIBLE_SWING_RANGE then -- Still prevents teleport if already close
								local originalParent = swordHandle.Parent
								local originalCFrame = swordHandle.CFrame
	
								swordHandle.Parent = workspace -- Temporarily unparent
	
								local targetHandleCFrame = enemyHRP.CFrame * CFrame.new(HIT_TELEPORT_OFFSET)
	
								swordHandle.CFrame = targetHandleCFrame
								task.wait(0.01)
								swordHandle.CFrame = originalCFrame
	
								swordHandle.Parent = originalParent
							end
							lastHitTime = tick() -- Update last hit time regardless of teleport or not
						end
					end
	
					-- Apply the subtle left/right rotation deviation to the *character*
					shakeDirection = -shakeDirection
					local deviatedCFrame = targetCFrame * CFrame.Angles(0, shakeMagnitude * shakeDirection, 0)
					LocalPlayer.Character:SetPrimaryPartCFrame(deviatedCFrame)
				else
					if swordBehaviorConnection then
						swordBehaviorConnection:Disconnect()
						swordBehaviorConnection = nil
					end
				end
			end)
		end
	
		classicsword.Equipped:Connect(function()
			isSwordEquipped = true
			if LocalPlayer.Character then
				manageSwordBehavior()
			else
				LocalPlayer.CharacterAdded:Wait()
				manageSwordBehavior()
			end
		end)
	
		classicsword.Unequipped:Connect(function()
			isSwordEquipped = false
		end)
	end
end;
task.spawn(C_4c);
-- StarterGui.GUI.Resources.LaserScript
local function C_4e()
local script = G2L["4e"];
	--Rescripted by Luckymaxer
	
	Tool = script.Parent
	Handle = Tool:WaitForChild("Handle")
	
	Players = game:GetService("Players")
	LocalPlayer = Players.LocalPlayer -- Get the local player
	
	ServerControl = Tool:WaitForChild("ServerControl")
	ClientControl = Tool:WaitForChild("ClientControl")
	
	ClientControl.OnClientInvoke = (function(Mode, Value)
		if Mode == "PlaySound" and Value then
			Value:Play()
		end
	end)
	
	function InvokeServer(Mode, Value, arg)
		pcall(function()
			ServerControl:InvokeServer(Mode, Value, arg)
		end)
	end
	
	function Equipped(Mouse)
		while Tool.Parent == LocalPlayer.Character do -- Keep looping while the tool is equipped
			local closestPlayer = nil
			local shortestDistance = math.huge
	
			-- Find the closest player
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
					local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
					if distance < shortestDistance then
						shortestDistance = distance
						closestPlayer = player
					end
				end
			end
	
			if closestPlayer then
				-- Aim at the closest player's HumanoidRootPart
				InvokeServer("Click", true, closestPlayer.Character.HumanoidRootPart.Position)
			end
			wait() -- Adjust the wait time as needed (e.g., 0.05 for 20 shots per second)
		end
	end
	
	local function Unequipped()
		-- This function will be called when the tool is unequipped.
		-- The `while` loop in Equipped will automatically stop when the Tool.Parent changes.
	end
	
	Tool.Equipped:connect(Equipped)
	Tool.Unequipped:connect(Unequipped)
end;
task.spawn(C_4e);

return G2L["1"], require;
